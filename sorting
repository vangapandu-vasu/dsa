Sorting
In base we 3 sorting algorithms:
1.Bubble sort
In bubble sorting we take the largest element and place it in the last of thee array and shorten the array from the last
In mean we take large array and place in last place then it is sorted from last
We compare every adjacent value and place the largest value at the end.
  Code for Bubble sort:
    void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap arr[j] and arr[j+1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

2.Selection sort
In selection sort we sort in the opposite way of bubble sort
In mean we intialize the first element to variable and if the next element is sammler than the assigned varible we swap that number
we search in the whole array and if we find any smaller element we will swap and reduce the array from the start

  code for Selection sort:
    void selectionSort(int[] arr) {
    int n = arr.length;

    for (int i = 0; i < n - 1; i++) {
        // Find the minimum element in the unsorted part
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        // Swap the found minimum with the first element
        int temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}

3.Insertion sort:
In insertion sort we take the array into two parts of sorted and unsorted
The first element is sorted and the rest part is unsorted we take the first element in unsorted and check if the previous(sorted element) is greater than him if it is we push the sorted element +1
and we place that in first place so we take every element and compare if they are greater move them one step a head and place it in its respected position

  code for Insertion sort:
    void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;

        // Move elements greater than key to one position ahead
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

These three algorithms make of O(n^2) complexity
If the array is half sorted the insertion sort takes around O(n)
These are not good enough for development and not optimised




    
